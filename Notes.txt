1.引用：
（1）类型相同
（2）必须初始化引用对象
2. 应用函数：
1）避免拷贝 2）作为输出函数，返回多个参数使用引用3）

3，内联函数：inline:
1）省去压参；2）比宏安全；执行效率高；3）函数名没有地址，不能赋给指针
缺点：
4，递归：
可读性好；增加空间使用效率
5，函数重载overlord
形参个数、形参类型、
与返回值无关
6.函数的默认参数：
socre_sum(int math ,int chinese, int c = 0; int cpp = 0)
(1)从左到右一次填充(2)二义性

7、函数模板：
(1)、如果参数时类类型：
template <class T>
template <typename T>
（2）、参数也可以是其他类型：
（3）、模板参数名不能与模板定义类型或者类名字相同

换型算法

8.class 和对象
成员函数及控制权限的问题
class和struct区别：
struct没有控制权限，全部都是可以访问的，public

9.this 指针
非静态函数

10.构造函数
类名==构造函数
C++11可以在构造函数中调用另一个构造函数

11.析构函数
析构函数 = ~类名
析构函数不能有参数
类最后执行的函数

先生成的后销毁，后生成的对象先销毁

12.动态内存的分配：
new： malloc+调用构造函数初始化
malloc：分配内存
delete：free+调用析构函数

13.深拷贝&浅拷贝
拷贝构造：在复制的过程中可以修改参数
1）没有返回参数
2）函数名字是类名
3）参数是const+类名 的类型
Student (const Student & s){}
六个特殊函数之一
浅拷贝：原目标一次拷贝到目的；只是拷贝了指针，没有拷贝内存；在执行到析构函数的时候会导致释放原指针内存，拷贝的指针变成野指针报错
深拷贝：添加拷贝构造函数，手动实现拷贝的动作，分配相应的内存

14.成员构造的顺序：
1）先构造类内的成员：自上而下进行构造
2）构造对象的自身
3）调用相应的其中一个构造函数
4）显示调用类内

15.静态成员变量和静态函数
静态成员变量：类似c中的全局变量，只是作用域有所不同；在类内定义为static
静态成员函数：不需要依赖对象；直接依靠类名就可以访问；没有this指针；

16.动态数组的操作：
（1）
（2）
（3）

17.友元函数：
（1）类内申明：普通函数+friend：可以访问类内所有的变量，包括private类型的
（2）友元类：

18.运算符重载
规则：（1）保持原有运运算符的意义（2）只能对已有的运算符重载，不能增加新的（3）重载的运算符不会改变原先的优先级和结合性

重载形式：成员函数、友元函数
成员函数：CLASS operator +
友元函数的形式：
必须是内成员形式重载，不能内外实现，即不能使用友元函数的方式：
=
()
[]
->
不能重载的运算符
.  成员运算符
::作用域运算符
*成员指针运算符
？ ：
sizeof
typeid一个RYYI运算符

临时对象和无名对象：


20：内嵌类：在类内定义的一个类，这个类作用域可以是全局的；
局部类：在函数体内定义的类，作用域：只在函数体内部有效

21：继承/派生
继承：子类具备父类所有的成员变量和方法
目的代码重用
派生：
目的：新的问题出现，原有的程序不能够解决，需要修改原代码
派生类的构造顺序：1.先父类，后子类
覆盖/重写：overwrite

单继承和多继承：
派生类可以从一个基类派生，称单继承
也可以从多个基类派生，称多继承

22.赋值兼容规则：
1、子类对象可以赋值基类
2、子类对象可以赋值基类对象的引用
3、子类对象可以赋值基类对象的指针

23.多态：
关键字：virtual
解决的问题：根据赋值兼容性规则，基类对象的指针或者引用访问子类对象时，会调用基类对象的方法，不会调用子类的方法。如果想要调用子类的方法，需要用到多态
多态的用法：
1、在基类方法加virtual
2、virtual也具备继承特性

24.抽象类：
抽象类：纯虚类，不能创建对象

25：多继承：
多继承：多个父类。一个派生类继承多个基类。
1、继承方式和单继承相同
2、构造方式：先基类，后派生类
3、多继承的构造，基类从左到右依次构造
4、调用基类与单继承相同

26.模板类：
1、模板类会在调用的时候生成相应的类
2、模板多次调用时不会生成多个类，编译器自动优化只保持一个类
3、模板一般在头文件中